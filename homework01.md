#Homework 1: `no silver bullet`
##Question 1
*Define the term essential difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an essential difficulty.*

Essential difficulties, as described by Brooks, are those difficulties inherent in the nature of the software.

The essence of a software entity is the collective of algorithms, data sets, functions and the relationships amongst the data items. These are inherently the building blocks of software development. Thus, essential problems deal with the primordial and conceptual structure of a software, indeed its essence. To develop a software it means to develop a vision which entangles the building blocks just mentioned. 

We encounter essential difficulties when the

##Question 2
*Define the term accidental difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an accidental difficulty.*


##Question 3
*List and briefly describe the four essential difficulties of developing software systems that Brooks identifies. Provide additional examples of each type of the four essential difficulties.*

Brooke’s identifies four subcategories to the essential difficulties:
* complexity
* conformity
* changeability
* invisibility

**Complexity** derives from the different layers of structure of the software. This translates in a huge number of states. Moreover, there is no linear correspondence of complexity when a system increases but rather exponential. An example of this can be the bionic prosthetic system: a prosthetic limb has to be able to interact with nerves skin and has to malleable to depending on the specific body. The software that menages it has to be able to interact with a variety of hardware components which might not be from the same producer, thus introducing heterogeneity. 

**Conformity** is a kind of difficulty seen when the system is prone to changes. If a particular system changes the software needs to be scalable and dynamic enough to not have to be rebuilt. 
For example, if at CU it is introduced a new school which allows students to not have a due date for when they can drop a class so they can always be refunded, our system has to be now compatible with this new feature and the old features (still applicable to the other schools - i.e. engineering, art and science etc…).

**Changeability** goes along with *conformity*; *changeability* is, indeed, the essential difficulty that deals with the fact that a software has to grow and change constantly. Visa USA has an incredible cybersecurity system; however, the field of cybersecurity is relatively new and unknown. Hackers finds continuously new ways to break into the systems, thus Visa needs to continuously update their softwares to protect the system form new creative attacks. 

**Invisibility** is the essential difficult which delineates the inherit property of a software: the code is \“invisible\” and \“intangible\”. 

##Question 4
Define what Brooks means by a silver bullet and reconstruct his argument as to why he believes there is no silver bullet for software engineering.

In lecture we discussed the concept of silver bullet and we developed its definition: 
a \“silver bullet\” is single technique or technology that by itself can deliver one order-of magnitude improvement to some aspect of software development. 
For Brooks there are not silver bullets in the sense that there is no actual \“cure against the software crisis\”. There is no way softwares can keep up with the the growth of computer hardware. 

Brooks argues that most techniques attack the accidents of software
engineering

In order to improve software development by a factor of 10
• first, the accidents of software engineering would have to account for
90% of the overall effort
• second, tools would have to reduce accidental problems to zero
• Brooks doesn't believe that the former is true…
• and the latter is nigh impossible because each new tool or technique
solves some problems while introducing others


##Question 5
In lecture, software engineering's relationship to computer science was described by analogy by discussing the differences between a chemist (chemistry) and a chemical engineer (chemical engineering). Define software engineering and its relationship to computer science; make use of the chemist vs. chemical engineer analogy when answering this question.


##Question 6
In lecture, we discussed the importance of the following concepts to software engineers: abstractions, conversations, specification, translation, and iteration. Define each of these concepts as they are related to software engineering and discuss their importance.